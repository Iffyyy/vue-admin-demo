<!-- 小册webgl的学习-->
<template>
  <canvas id="container" />
</template>

<script lang="ts">
import { Component, Vue } from 'vue-property-decorator'
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import Stats from 'three/examples/jsm/libs/stats.module.js'
import { shapesData } from './data'

let container:any, stats:any

let camera:any, scene:any, renderer:any

let group:any

let targetRotation = 0
let targetRotationOnPointerDown = 0

let pointerX = 0
let pointerXOnPointerDown = 0

let windowHalfX = window.innerWidth / 2

@Component({
  name: 'Three'
})
export default class extends Vue {
  mounted() {
    this.init()
    this.animate()
  }

  init() {
    const lineColor = 0x0000ff
    const areaColor = 0xf08000

    container = document.createElement('div')
    document.body.appendChild(container)
    // container = document.getElementById('container') as HTMLCanvasElement

    scene = new THREE.Scene()
    scene.background = new THREE.Color(0xf0f0f0)
    // scene.position.set(-10702.182460893877, -6303.1763131096959, 0)
    scene.add(new THREE.AxesHelper(2000))

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000)
    camera.position.set(0, 150, 500)
    scene.add(camera)

    const light = new THREE.PointLight(0xffffff, 0.8)
    camera.add(light)

    group = new THREE.Group()
    group.position.y = 0
    scene.add(group)

    function addShape(shape:any, extrudeSettings:any, color:any, x:number, y:number, z:number, rx:number, ry:number, rz:number, s:number) {
      // flat shape with texture
      // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices

      // extruded shape

      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings)

      const mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: color }))
      mesh.position.set(x, y, z)
      mesh.rotation.set(rx, ry, rz)
      mesh.scale.set(s, s, s)
      group.add(mesh)
      addLineShape(shape, lineColor, x, y, z, rx, ry, rz, s)
    }

    function addLineShape(shape:any, color:any, x:number, y:number, z:number, rx:number, ry:number, rz:number, s:number) {
      // lines

      shape.autoClose = true

      const points = shape.getPoints()

      const geometryPoints = new THREE.BufferGeometry().setFromPoints(points)

      // solid line

      const line = new THREE.Line(geometryPoints, new THREE.LineBasicMaterial({ color: color }))
      line.position.set(x, y, z + 18)
      line.rotation.set(rx, ry, rz)
      line.scale.set(s, s, s)
      group.add(line)
    }

    function printShape(polygon:any) {
      // California

      const californiaPts:any = []

      polygon.forEach((element:number[]) => {
        californiaPts.push(new THREE.Vector2(...element))
      })

      for (let i = 0; i < californiaPts.length; i++) californiaPts[i].multiplyScalar(0.25)

      const californiaShape = new THREE.Shape(californiaPts)

      const extrudeSettings = { depth: 400, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 }

      addShape(californiaShape, extrudeSettings, 0xf08000, 60, 160, 0, 0, 0, 0, 0.044)
    }

    shapesData.forEach(item => {
      printShape(item.polygon)
    })

    //

    renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setPixelRatio(window.devicePixelRatio)
    renderer.setSize(window.innerWidth, window.innerHeight)
    container.appendChild(renderer.domElement)
    const controls = new OrbitControls(camera, renderer.domElement)

    // @ts-ignore
    stats = new Stats()
    container.appendChild(stats.dom)

    container.style.touchAction = 'none'
    container.style.position = 'absolute'
    container.style.top = '0'
    container.addEventListener('pointerdown', this.onPointerDown)

    //

    window.addEventListener('resize', this.onWindowResize)
  }

  onWindowResize() {
    windowHalfX = window.innerWidth / 2

    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()

    renderer.setSize(window.innerWidth, window.innerHeight)
  }

  onPointerDown(event:any) {
    if (event.isPrimary === false) return

    pointerXOnPointerDown = event.clientX - windowHalfX
    targetRotationOnPointerDown = targetRotation

    document.addEventListener('pointermove', this.onPointerMove)
    document.addEventListener('pointerup', this.onPointerUp)
  }

  onPointerMove(event:any) {
    if (event.isPrimary === false) return

    pointerX = event.clientX - windowHalfX

    targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02
  }

  private onPointerUp(event:any) {
    if (event.isPrimary === false) return

    document.removeEventListener('pointermove', this.onPointerMove)
    document.removeEventListener('pointerup', this.onPointerUp)
  }

  private animate() {
    requestAnimationFrame(this.animate)

    this.renderGl()
    stats.update()
  }

  renderGl() {
    group.rotation.y += (targetRotation - group.rotation.y) * 0.05
    renderer.render(scene, camera)
  }
}
</script>
<style lang="scss" scoped>
#container{
  width: 100vw;
  height: 100vh;
}
</style>
